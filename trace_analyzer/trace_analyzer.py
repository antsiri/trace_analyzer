#!/usr/bin/env python3import base64import socketimport reimport datetimeimport globimport argparseimport osimport scapyimport scapy.allimport scapy.layersfrom scapy.all import Raw, rdpcapfrom scapy.all import TCP_SERVICES as TCPfrom scapy.layers import httpfrom scapy.packet import bind_layersfrom argparse import ArgumentParserdef __tcp_stream__(directory):    print('tcpstream')    sPort = []    dPort = []    senderPackets = []    receiverPackets = []    senderBytes = []    receiverBytes = []    senderACK = []    receiverACK = []    outOfseqSender = []    outOfseqReceiver = []    seqNumSender = []    seqNumReceiver = []    seqNum = []    senderRetransmit = []    receiverRetransmit = []    retransmit = []    totalBytes = []    usefulBytes = []    usefulPackets = []    startTime = []    stopTime = []    cwnd = []    cwnd_max = []    receiverWindow = []    SYN = 2    ACK = 16    PSH = 24    i = 0    count = 0    os.chdir('/Users/antoniosirignano/Desktop/Università/Ingegneria Informatica N46/3° Anno/1° Semestre/Reti di calcolatori I/Rilevazioni laboratorio/RDC_G007/1636104984')    for pcap_file in glob.glob('*.pcap') :        print("File founded: %s" % (pcap_file))        pcap = rdpcap(pcap_file)    for packet in pcap:        try:            if packet[TCP].flags == SYN:                sPort.append(packet[TCP].sport)                dPort.append(packet[TCP].dport)                senderPackets.append(0)                receiverPackets.append(0)                senderACK.append(0)                receiverACK.append(0)                outOfseqSender.append(0)                outOfseqReceiver.append(0)                seqNumSender.append(packet[TCP].seq)                seqNumReceiver.append(0)                senderBytes.append(0)                receiverBytes.append(0)                senderRetransmit.append(0)                receiverRetransmit.append(0)                startTime.append(packet.time)                stopTime.append(0)                totalBytes.append(len(packet))                usefulBytes.append(0)                usefulPackets.append(0)                cwnd_max.append(0)                receiverWindow.append(0)            if packet[TCP].sport in sPort:                stopTime[sPort.index(packet[TCP].sport)] = packet.time                if packet[TCP].flags != SYN:                    totalBytes[sPort.index(packet[TCP].sport)] = totalBytes[sPort.index(packet[TCP].sport)] + len(                        packet)                if packet[TCP].seq in seqNum:                    if packet[TCP].flags not in (ACK, PSH):                        print(packet[TCP].flags)                        senderRetransmit[sPort.index(packet[TCP].sport)] = senderRetransmit[                                                                               sPort.index(packet[TCP].sport)] + 1                else:                    seqNum.append(packet[TCP].seq)                if packet[TCP].seq < seqNumSender[sPort.index(packet[TCP].sport)]:                    outOfseqReceiver[sPort.index(packet[TCP].sport)] = outOfseqSender[                                                                           sPort.index(packet[TCP].sport)] + 1                else:                    seqNumSender[sPort.index(packet(TCP).sport)] = packet[TCP].seq                    try:                        usefulBytes[sPort.index(packet[TCP].sport)] = usefulBytes[sPort.index(packet[TCP].sport)] + len(                            packet[Raw])                    except:                        pass                senderPackets[sPort.index(packet[TCP].sport)] = senderACK[sPort.index(packet(TCP).sport)] + 1                if packet[TCP].flags == ACK:                    senderACK[sPort.index(packet[TCP].sport)] = senderACK[sPort.index(packet[TCP].sport)] + 1                try:                    print(len(packet))                    senderBytes[sPort.index(packet[TCP].sport)] = senderBytes[sPort.index(packet[TCP].sport)] + len(                        packet[Raw])                    usefulPackets[sPort.index(packet[TCP].sport)] = usefulPackets[sPort.index(packet[TCP].sport)] + 1                    if len(packet[Raw]) > cwnd_max[sPort.index(packet[TCP].sport)]:                        cwnd_max[sPort.index(packet[TCP].sport)] = len(packet[Raw])                except:                    pass            elif packet[TCP].sport in dPort:                receiverWindow[sPort.index(packet[TCP].dport)] = receiverWindow[sPort.index(packet[TCP].dport)] + \                                                                 packet[TCP].window                stopTime[sPort.index(packet[TCP].dport)] = packet.time                totalBytes[sPort.index(packet[TCP].dport)] = totalBytes[sPort.index(packet[TCP].dport)] + len(packet)                if packet[TCP].seq in seqNum:                    if packet[TCP].flags not in (ACK, PSH):                        print(packet[TCP].flags)                        receiverRetransmit[sPort.index(packet[TCP].dport)] = receiverRetransmit[                                                                                 sPort.index(packet[TCP].dport)] + 1                else:                    seqNum.append(packet[TCP].seq)                if packet[TCP].seq < seqNumReceiver[sPort.index(packet[TCP].dport)]:                    outOfseqReceiver[sPort.index(packet[TCP].dport)] = outOfseqReceiver[                                                                           sPort.index(packet[TCP].dport)] + 1                else:                    seqNumReceiver[sPort.index(packet[TCP].dport)] = packet[TCP].seq                    try:                        usefulBytes[sPort.index(packet[TCP].dport)] = usefulBytes[sPort.index(packet[TCP].dport)] + len(                            packet[Raw])                    except:                        pass                receiverPackets[sPort.index(packet[TCP].dport)] = receiverACK[sPort.index(packet[TCP].dport)] + 1                if packet[TCP].flags == ACK:                    receiverACK[sPort.index(packet[TCP].dport)] = receiverACK[sPort.index(packet[TCP].dport)] + 1                try:                    receiverBytes[sPort.index(packet[TCP].dport)] = receiverBytes[sPort.index(packet[TCP].dport)] + len(                        packet[Raw])                except:                    pass        except:            print("Error")            continue    while i < len(sPort):        gp = 0        tp = 0        rw = 0        rw = receiverWindow[i] / receiverPackets[i]        cwnd.append(senderBytes[i] / usefulPackets[i])        tp = totalBytes[i] / (stopTime[i] - startTime[i])        gp = usefulBytes[i] / (stopTime[i] - startTime[i])        print("<begin: TCP Flow"  + str(i + 1))        retransmit.append(senderRetransmit[i] + receiverRetransmit[i])        print('# packets sent by the sender: ' + str(senderPackets[i]))        print('# packets sent by the receiver: ' + str(receiverPackets[i]))        print('# bytes sent by the sender: ' + str(senderBytes[i]))        print('# bytes receiver by the receiver: ' + str(receiverBytes[i]))        print('# ACKs sent by the sender: ' + str(senderACK[i]))        print('# ACKs sent by the receiver: ' + str(receiverACK[i]))        print('Largest congestion window size at sender: ' + str(cwnd_max[i]))        print('Average congestion window size at sender: ' + str(cwnd[i]))        print('Average receiver window size: ' + str(rw))        print('# retransmissions: ' + str(retransmit[i]))        print('# Out of Order packets: ' + str(outOfseqSender[i] + outOfseqReceiver[i]))        print('Throughput: ' + str(tp))        print('Goodput: ' + str(gp))        i = i + 1        print('END FLOW>\n\n')def __parse_pcap__(directory, out=None):    bind_layers(TCP, http.HTTP, sport=80)    bind_layers(TCP, http.HTTP, dport=80)    os.chdir(directory)    for pcap_file in glob.glob('*.pcap') :        print("File founded: %s" % (pcap_file))        pcap = rdpcap(pcap_file)        flows = pcap.filter(lambda s: http.HTTPResponse in s)        html_begin_found = False        html_end_found = False        html = ""        for flow in flows:            payload = flow[http.HTTP].payload            if not html_begin_found:                token_re = re.compile(                    r'Content-Type:\s+text/html', re.IGNORECASE)                m = token_re.search(str(payload))                if (m is None):                    continue                else:                    html_begin_found = True            else:                token_re = re.compile(r'</html', re.IGNORECASE)                m = token_re.search(str(payload))                if (m is not None):                    html_end_found = True            if (html_begin_found):                tmp_html = str(payload)                if (tmp_html is not None):                    tmp_html = __extract_html__(tmp_html)                    if (tmp_html is not None):                        html += tmp_html            if (html_begin_found and html_end_found):                html_end_found = False                html_begin_found = False                if (html is not None):                    if (out is None):                        print('ops')                    else:                        filename = os.path.basename(pcap_file)                        if (os.path.exists("%s-%s.html" % (out, filename))):                            i = 0                            while (os.path.exists("%s//%s-%s.html" % (out, filename, i))):                                i = i + 1                            filename = "%s-%s" % (filename, i)                        fd = open("%s/%s.html" % (out, filename), "wb")                        fd.write(html)                        fd.close()            html = ""    returndef __extract_html__(payload_str):    low = -1    high = -1    low_p = payload_str.lower()    index = low_p.find("<!doctype_html")    if (index == -1):        index = low_p.find("<html")        if (index >= 0):            low = index        else:            low = index        index = low_p.find("</html>")        if (index >= 0):            high = index + len("</html")        if (low >= 0 and high >= 0):            return payload_str[low:high]        elif (low >= 0):            return payload_str[low:]        elif (high >= 0):            return payload_str[:high]        else:            return Nonedef main():    parser = ArgumentParser(description='Parse PCAP files and search for Angler traces')    parser.add_argument('-dir', '--directory', help='Directory where to search for PCAP to analyse.')    parser.add_argument('-out', '--output_directory',                        help='Directory where to wrote all information extracted (by default stdout)')    args = parser.parse_args()    # Check if an output directory is set    directory = None   # if (args.output_directory):       # directory = os.path.dirname(args.output_directory)        #if not (os.path.exists(directory)):          #  os.makedirs(directory)    #print(directory)    #__parse_pcap__(args.directory, args.directory)    __tcp_stream__(args.directory)        #else:       #     print("You need to specify a directory where to search for pcap file")if __name__ == "__main__":   main()